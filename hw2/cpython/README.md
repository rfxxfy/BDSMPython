# CPython v1.1

## Легенда

Спустя несколько дней после получения задания, Кеша вернулся к Вовке с полным непониманием того, что
происходит. Вовка, будучи опытным инженером, повторно проанализировал задачу и понял, что ее можно
немного упростить, чтобы бедному попугаю было проще освоиться на новом месте.

<details>

<summary>
<i>Если Вы не читали или забыли условие предыдущей версии задачи, то предлагаем вспомнить здесь.</i>
</summary>

Попугай Кеша каким-то образом попал на стажировку в IT-команду *"Союзмультфильма"*. Не теряя ни
минуты, он заявил, что когда в последний раз отдыхал на Таити, выучил `C++` и `Python`. Однако
попугай не учел, что ему могут выдать задание.

Руководитель команды Вовка давно хотел совместить `Python` и `C++`, используя `CPython` API. На
всякий случай, напомним пернатому другу, что каноническая реализация `Python` - это `CPython`. Как
понятно из названия, `Python` написан на `C`.

В команде используют систему сборки `Bazel`. Она очень требовательна к объявлению зависимостей. Все
файлы должны быть предоставлены заранее, равно как и остальные параметры и настройки. И все бы
ничего, но команда Вовки так и не определилась с версией `Python`, которую она будет использовать.
Если учитывать минорные версии, то между `3.8.0` и `3.12.4` вышло *69* версий! Никто не будет писать
конфигурации под 69 возможных случаев. Это мы еще не учли поиск самих файлов! Тем не менее,
компилировать проект как-то надо.

Кеша, как обычно, свою задачу повесил на Вас! Внимательно прочитайте техническое задание и помогите
Кеше дожить до первой зарплаты.

</details>

## Техническое задание

### Краткое описание

Вам необходимо написать программу, которая:

1. Проверит текущую систему на ограничения;
2. Удалит файлы, которые остались с предыдущих запусков этой программы;
3. Найдет файлы `Python`, которые необходимы для сборки проекта;
4. Скопирует найденные файлы в директорию, выделенную для сборки проекта;
5. Запишет конфигурационный файл для `Bazel`, опираясь на скопированные файлы.

### Ограничения системы

Вовка сразу напомнил забывчивому попугаю ограничения, предъявляемые командой:

1. Никакая реализация языка, кроме `CPython`, нас не интересует. Действительно, как можно
   пользоваться `CPython` API, если нет самого `CPython`!

2. Хотим видеть версию `Python` не младше `3.8.0`, так как именно с этой версии появляется нужная
   Вовке фича. Без нее совсем никак!

3. Команда гарантирует стабильность своих приложений только на `Linux`, `Windows` и `macOS`, поэтому
   программу разрешено запускать только на них. Никакие `JavaOS` предусматривать не нужно.

Если какое-либо из условий нарушено, то Кеша должен вызвать исключение `AssertionError` с понятным
для пользователя сообщением. Например:

```python
def main() -> None:
    if not is_cpython():
        detail = "The Python implementation is not CPython"
        raise AssertionError(detail)

    ...
```

### Система сборки

Для сборки на `Bazel` будет использовано правило `cc_import`. Его применяют для импортирования
заранее скомпилированных библиотек для `C` или `C++`. Давайте покажем пример, чтобы было более
понятно, что от Вас потребуется дальше.

```python
cc_import(
    ...,
    hdrs = [
        "dir/bar.h",
        "dir/baz.h",
    ],
    ...,
    shared_library = "mylib.dll",
    interface_library = "mylib.lib",
    ...,
)
```

Содержимое записывают в конфигурационный файл `BUILD.bazel`. Он декларирует, какие действия должна
совершить система сборки, чтобы скомпилировать (или загрузить) библиотеку или исполняемый файл. В
частности, для примера выше будет справедливо:

* Атрибут `hdrs` указывает, какие заголовочные файлы предоставляет объявленная цель сборки. Это
  значит, что после импорта пользователь сможет использовать файлы `dir/bar.h` и `dir/baz.h` в своей
  программе (через `#include`).

  Обратите внимание, что путь записывается относительно `BUILD.bazel` файла. Например, если
  `BUILD.bazel` находится в директории `/a/b/c`, то заголовочные файлы имеют следующие полные пути:
  `/a/b/c/dir/bar.h` и `/a/b/c/dir/baz.h`

* Атрибут `shared_library` указывает, какую разделяемую библиотеку нам необходимо импортировать,
  чтобы заголовочные файлы из `hdrs` стали доступными. Проще говоря, это и есть уже скомпилированная
  библиотека.

  Обратите внимание, что путь, как и в примере выше, записывается относительно `BUILD.bazel` файла.

* Атрибут `interface_library` указывает, какой интерфейс должен быть использован при линковке
  разделяемой библиотеки. Считайте, что это просто некоторый файл, который нужен из-за особенностей
  компиляции.

  Обратите внимание, что путь, как и в примерах выше, записывается относительно `BUILD.bazel` файла.

### Алгоритмы

#### Поиск

##### Заголовочные файлы (`hdrs`)

К заголовочным файлам отнесем все файлы с расширением `.h`, которые находятся в директории для
**НЕ**платформозависимых заголовочных файлов. Изучите документацию к `sysconfig`, чтобы узнать, как
получить путь до этой директории.

##### Корень CPython

Корнем `CPython` считайте директорию для данных. Изучите документацию к `sysconfig`, чтобы узнать,
как получить путь до этой директории.

##### Разделяемая библиотека (`shared_library`)

Сначала определим, где будем искать (*директория поиска*):

* На `Windows` используем корень `CPython`;
* На `macOS` и `Linux` используем путь из конфигурационной переменной `LIBDIR`.

Далее, предполагая, что версия `Python` - это `{major}.{minor}.{patch}`, необходимо найти файл, имя
которого удовлетворяет паттерну:

* На `Windows` ищем `python{major}{minor}.dll`;
* На `macOS` ищем `libpython{major}.{minor}.dylib`;
* На `Linux` ищем `libpython{major}.{minor}.so`.

Гарантируется, что файл ровно один и он существует. Файл может быть вложен в какие-то директории
относительно директории поиска.

##### Библиотека-интерфейс (`interface_library`)

Библиотека-интерфейс нужна только для `Windows`. На `macOS` и `Linux` библиотека-интерфейс не
требуется - искать ее не нужно.

*Директорией поиска* является корень `CPython`. Внутри его директории `libs/` требуется найти файл,
имя которого удовлетворяет паттерну `python{major}{minor}.lib`.

Гарантируется, что файл ровно один и он существует. Файл может быть вложен в какие-то директории
относительно директории поиска.

#### Копирование

Представим, что мы нашли некоторый файл в *директории поиска*. Его будет необходимо скопировать в
директорию, выделенную под файлы, требуемые для сборки. Этой директорией является
`third_party/cpython/internal/` относительно текущей рабочей директории.

Удалять оригинальный файл не требуется - только скопировать. При этом для найденного файла при
копировании требуется сохранить путь относительно *директории поиска*. Немного поясним.

Например, мы искали заголовочные файлы в некоторой директории поиска `/a/b/c`. Если бы мы нашли
файл, который имеет путь `/a/b/c/dir/file.h`, то он бы был скопирован как
`./third_party/cpython/internal/dir/file.h`, потому что `dir/file.h` - это путь к файлу относительно
*директории поиска*.

#### Конфигурационный файл

После того, как Вы нашли все пути и скопировали файлы в директорию сборки, Вам останется только
создать конфигурационный файл для `Bazel`.

В файл `./third_party/cpython/BUILD.bazel` Вы должны записать следующее содержимое:

```python
cc_import(
    name = "cpython",
    hdrs = [
        "...",
        "...",
        "...",
    ],
    includes = ["internal"],
    interface_library = "...",
    shared_library = "...",
    visibility = ["//visibility:public"],
)
```

Вместо многоточий будут записаны пути до скопированных файлов относительно директории
`./third_party/cpython/`. Про это мы писали, когда объясняли, за что отвечает каждый атрибут.

Например, если мы нашли некоторый заголовочный файл и скопировали его как
`./third_party/cpython/internal/dir/file.h`, то в атрибут `hdrs` мы запишем его как
`internal/dir/file.h`.

К слову, из этого требования следует, что все файлы из `hdrs`, `interface_library` и
`shared_library` имеют префикс `internal/`, потому что мы копировали все файлы в
`./third_party/cpython/internal/`.

Если мы работаем на `Linux` или `macOS`, то атрибут `interface_library` не должен быть записан в
`BUILD.bazel`, потому что на этих платформах, как было ранее упомянуто, библиотека-интерфейс не
требуется. Проще говоря, Вы запишите на одну строку меньше.

#### Защита от перезапусков

Поскольку версия `Python` между запусками Вашей программы может меняться, то нам необходимо
предусмотреть механизм предварительной очистки `./third_party/cpython/` от каких-либо файлов,
чтобы ничего лишнего не попало в сборку (например, от предыдущих запусков).

Вам необходимо удалять директорию `./third_party/cpython/` вместе с ее содержимым при повторных
запусках программы.

## Подсказки

Вам наверняка будут полезны следующие методы:

* `pathlib.Path.glob`;
* `pathlib.Path.rglob`;
* `pathlib.Path.relative_to`;
* `shutil.rmtree(..., ignore_errors=True)`.
